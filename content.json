{"meta":{"title":"Dylan的壁炉","subtitle":"外面冷！","description":"你好","author":"Dylan So","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2021-04-19T08:14:26.000Z","updated":"2021-04-19T08:14:40.485Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-04-19T08:12:11.000Z","updated":"2021-04-19T08:14:12.406Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"大话数据结构笔记","slug":"大话数据结构笔记","date":"2021-04-20T15:36:07.000Z","updated":"2021-04-21T07:40:13.656Z","comments":true,"path":"2021/04/20/大话数据结构笔记/","link":"","permalink":"http://example.com/2021/04/20/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/","excerpt":"","text":"第一章：数据结构绪论数据：描述客观事物的符号，能被计算机识别、操作、处理的符号集合 数据对象：性质相同的数据元素集合，是数据的子集 数据元素(记录)：有意义的基本单位(人类-&gt;人) 数据项：最小单位，比数据元素小(耳朵) 数据结构：相互之间存在一种或多种特定关系的数据元素合集 逻辑结构集合结构(~)，线性结构(1-1)，树形结构(1-n)，图形结构(n-m) 结点，关系(无/有箭头) 物理结构顺序储存结构，链式储存结构(连续/不连续) 数据类型原子类型(不可分解)，结构类型(原子组合)，抽象类型 第二章：算法算法是解决特定问题求解步骤的描述 算法的特性输入，输出，有穷性，确定性(二义性)，可行性 算法设计的要求正确性，可读性，健壮性，高效性，存储量低 算法效率的度量方法事后统计法，事前分析估算法 规模n无限制，总有一个数值N标定两个算法的效率平衡(渐进增长) n&gt;N时，总有f(n)&gt;g(n)，则f(n)渐进增长快于g(n) 主要看最高阶项的阶数 算法时间复杂度T(n)=O(f(n))，随着n的增大，T(n)增长最慢的算法为最优算法 O(1)常数阶 O(n)线性阶 O(n^2)平方阶 … 推导大O阶： ​ 用常数1取代运行时间中的所有加法常数 在修改后的运行次数函数中，只保留最高阶项 若最高阶项存在且不是1，则去除与这个项相乘的常数 分支结构：常数阶 循环结构：线性阶 *结构：对数阶 循环嵌套：平方阶 常数阶&lt;对数阶&lt;线性阶&lt;nlogn阶&lt;平方阶&lt;立方阶&lt;指数阶&lt;阶乘阶&lt;n^n阶 最坏情况与平均情况 算法空间复杂度S(n)=O(f(n)) O(1)原地工作 第三章：线性表线性表：零个或多个数据元素的有限序列每个元素有一个前驱和一个后继，第一个和最后一个除外 元素个数n为线性表长度，特殊的，n=0时称为空表 在较复杂的线性表中，一个数据元素可以由若干个数据项组成(如表格) 操作：重置，查存，索引，插入元素，删除元素，获得长度 顺序存储结构#define MAXSIZE 20 typedef int ElemType; typedef struct&#123; ElemType data[MAXSIZE]; int length; &#125;SqList; 获取元素： int GetElem(SqList L,int i,ElemType *e) &#123; if (L.length == 0 || i&lt;1 || i&gt;L.length) &#123; return false;//Out of edge &#125; *e = L.data[i - 1]; return true; &#125; 插入元素： int ListInsert(SqList *L, int i, ElemType *e) &#123; int k; if (L-&gt;length == MAXSIZE) &#123;//Full list return false; &#125; if (i &lt; 1 || i &gt; L-&gt;length + 1) &#123;//Out of edge return false; &#125; if (i &lt;= L-&gt;length) &#123;//Isn&#39;t at the end of the list for (k = L-&gt;length - 1; k &gt;= i - 1; k--) &#123; L-&gt;data[k + 1] = L-&gt;data[k];//Move each elems position behind &#125; &#125; L-&gt;data[i - 1] = *e;//At the end of the list L-&gt;length++; return true; &#125; 删除元素： int ListDelete(SqList *L,int i,ElemType *e) &#123; int k; if (L-&gt;length == 0) &#123;//List is empty return false; &#125; if (i&lt;1 || i&gt;L-&gt;length) &#123;//Out of edge return false; &#125; *e = L-&gt;data[i - 1]; if (i &lt; L-&gt;length) &#123;//Isn&#39;t at the end of the list for (k = i; k &lt; L-&gt;length; k++) &#123; L-&gt;data[k - 1] = L-&gt;data[k];//Move each elems position behind &#125; &#125; L-&gt;length--; return true; &#125; 删除和插入操作算法着重多练(最坏时间复杂度O(n)) 优点：淡化逻辑关系，快速存取表中任意元素 缺点：插入和删除开销大，表长变化大时难以确定存储空间大小，不能精确利用内存 链式存储结构存储映像(结点Node) 数据域：储存数据元素本身 指针域：储存直接后继的位置(指针/链) 只包含一个指针域：单链表 第一个结点的存储位置：由头指针指向 最后一个结点的指针域：存放空指针(NULL) 在第一个结点前可附加“头结点”，可存放长度等附加信息 单链表的操作： 读取：遍历，最坏时间复杂度O(n) 插入：指针指向后继，前一元素指针指向自己，最坏时间复杂度O(n) 删除：释放自身，前驱指针直接指向后继，最坏时间复杂度O(n) 整表创建：创建表头-&gt;头插法/尾插法 整表删除：从头逐个释放 优点：插入、删除越频繁，效率优势越明显 缺点：读取是劣势 静态链表data、cur(游标、相当于指针) 使用较大数组，下标作为地址 静态链表的操作： 插入：先将要插入的元素排在最后，后面与单链表类似 删除：类似 优点：相对于顺序存储结构，插入和删除时不需要移动大量元素 缺点：还是没有解决表长难以确定的问题，无随机存取的特性 循环链表(circular linked list)首尾相连的单链表，尾指针-&gt;头指针 合并链表 p = rearA -&gt; next; rearA -&gt; next = rearB -&gt; next -&gt; next; q = rearB -&gt; next; rearB -&gt; next = p; free(q); 双向链表(double linked list)每个数据元素的指针域添加指向直接前驱的指针，链表首尾相连 插入： p -&gt; prior = p; s -&gt; next = p -&gt; next; p -&gt; next -&gt; prior = s; p -&gt; next = s; 删除： p -&gt; prior -&gt; next = p -&gt; next; p -&gt; next -&gt; prior = p -&gt; prior; free(p); 第四章：栈与队列","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"经济学原理:微观经济学分册|曼昆|学习笔记","slug":"经济学原理-微观经济学分册-曼昆-学习笔记","date":"2021-04-19T10:44:37.000Z","updated":"2021-04-19T10:46:42.875Z","comments":true,"path":"2021/04/19/经济学原理-微观经济学分册-曼昆-学习笔记/","link":"","permalink":"http://example.com/2021/04/19/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86-%E5%BE%AE%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%88%86%E5%86%8C-%E6%9B%BC%E6%98%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"经济学原理—微观经济学||曼昆 例子 每章前面有名词总览 第一篇—导言第一章—经济学十大原理稀缺性(scarcity)：社会资源的有限性 经济学(economics)：研究社会如何管理自己的稀缺资源 效率(efficiency)：社会能从其稀缺资源中得到最大利益的特性 平等(equality)：经济成果在社会成员中平均分配的特性 机会成本(opportunity cost)：为了得到某种东西所必须放弃的东西 理性人(rational people)：系统而有目的地尽最大努力实现其目标的人 边际变动(marginal change)：对行动计划的微小增量调整 边际成本(marginal cost)：一次决策所需的真实成本# 边际收益(marginal benefit)：一次决策所带来的真实收益# 激励(incentive)：引起一个人做出某种行为的某种东西 市场经济(market economy)：多个个体在物品与服务市场上相互交易，通过分散的决策来配置资源的经济体系 产权(property rights)：个人拥有并控制稀缺资源的能力 市场失灵(market failure)：市场本身不能有效配置资源的情况 外部性(externality)：一个人的行为对旁观者福利的影响 市场势力(market power)：单个经济活动者(或某个经济活动小群体)对市场价格有显著影响的能力 1.1人们如何作出决策1.1.1原理一：人们面临权衡取舍做出决策就是要求我们在不同目标之间进行权衡取舍 平等的分配政策&lt;–(矛盾)–&gt;个人所得税 (政府取舍) 1.1.2原理二：某种东西的成本是为了得到它所放弃的东西 上大学 1.1.3原理三：理性人考虑边际量一个人对任何一种物品和服务的支付意愿都基于获得该物品和服务所获得的边际收益 水和钻石 1.1.4原理四：人们会对激励做出反应 苹果、石油税、安全带、开车 1.2人们如何相互影响1.2.1原理五：贸易可以使每个人的状况都变得更好 社会分工、合作共赢 1.2.2原理六：市场通常是组织经济活动的一种好方法价格是指引经济活动的工具 市场经济是目前社会资源配置的最优解？ 税收对资源配置不利 1.2.3原理七：政府有时可以改善市场结果政府制度：促进效率或促进平等 外部性：污染 市场势力：井","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"经济学","slug":"经济学","permalink":"http://example.com/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"}]},{"title":"我的开发手册","slug":"我的开发手册","date":"2021-04-19T10:43:49.000Z","updated":"2021-04-19T11:02:06.832Z","comments":true,"path":"2021/04/19/我的开发手册/","link":"","permalink":"http://example.com/2021/04/19/%E6%88%91%E7%9A%84%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/","excerpt":"","text":"暂未开放","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"开发文档","slug":"开发文档","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/"}]},{"title":"8086汇编笔记","slug":"8086汇编笔记","date":"2021-04-19T10:43:01.000Z","updated":"2021-04-19T11:03:27.561Z","comments":true,"path":"2021/04/19/8086汇编笔记/","link":"","permalink":"http://example.com/2021/04/19/8086%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/","excerpt":"","text":"配置环境DosBox+masm工具集 ​ 1、创建一个用于保存汇编工具（如MASM、Link、DEBUG等工具）和汇编文件（*.asm）的目录，如：D:\\DEBUG。(实际会用到的有以下程序：debug.exe edit.com link.exe masm.exe ) ​ 2、下载并安装DOSBox后打开程序，会出现如图所示的两个界面， ​ 只需关心下图所示界面，另外一个界面无需关注，可以最小化但是不能关闭它。 ​ 4、在上面选中界面依次输入以下命令(命令行不区分大小写)： ​ 第一步：MOUNT C D:\\DEBUG（回车）( 将目录 D:\\DEBUG 挂载为DOSBOX下的 C: ) ​ PS:这里 D:\\DEBUG 是之前创建的工作目录，根据自己的目录输入 第二步：C:（回车）(进入挂载后的C盘) ​ 前两步执行结果如下图 这样我们就进入了DOS的环境，可以编写汇编程序了。 为了避免每一次进入界面都要输入上面的命令,我们可以进行下面的简单配置，使得以后使用时可以直接进入我们想要的目录。 打开C:\\Users\\Administrator\\AppData\\Local\\DOSBox\\dosbox-0.74.conf 在文件末尾添加以下内容： MOUNT C D:\\DEBUG C: 再次运行DOSBox时就可以看到直接进入了下图所示界面 如何编译运行​ 在挂载处编写代码 ​ 打开dosbox 输入masm test.txt ​ 在0 severe errors的情况下会在挂载处生成TEST.OBJ ​ 接着输入link TEST.OBJ ​ 此时生成TEST.exe ​ 输入debug TEST.exe ​ 用r命令查看寄存器，用t命令单步运行 ​ 寄存器ax的值由FFFF变为5 ​ 对应着mov ax，5 ​ 完毕 一、基础知识汇编语言组成 汇编指令：机器码助记符,有对应机器码 (如1000100111011000 对应 mov ax,bx) 伪指令：无对应机器码，由编译器执行，计算机不执行 其他符号：其他符号(+-*/)，由编译器识别，无对应机器码 一样的机器码可以对应数据或指令（看应用场景） 名词 储存单元：从0开始编码，线性排列，一字节一单元 总线宽度：每条线以高电平和低电平表示0或1，宽度为10代表10条线，能传输2^10(1024)种数据，宽度代表能力(寻址能力，控制能力，数据传输量) 主板：板上集成了各种器件(CPU，储存器，外围芯片组，拓展插槽等)，通过总线连接，槽上一般有RAM内存和各类接口卡 接口卡：CPU直接控制接口卡，接口卡对外设进行控制，从而CPU间接控制外设 各类储存器芯片： 随机存储器 RAM(Random Access Memory) ​ 存放供CPU使用的数据和程序 ​ 显卡上叫显存，将要显示的内容写入显存 只读存储器 ROM(Read-Only Memory) ​ 只能读，不能写的内存，一般装有BIOS(Basic Input Output System) CPU对储存的应用 寻址 ​ 通过地址总线 控制 ​ 通过控制总线 数据传递 ​ 通过数据总线 内存地址空间 ​ 所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器 ​ 每个存储器都有相应的地址空间 二、寄存器前置知识 名词 寄存器：CPU中程序员可以用指令读写的部件 通用寄存器：存放一般性的数据 段寄存器：存放段地址 通用寄存器包含AX(AH、AL)、BX(BH、BL)、CX(CH、CL)、DX(DH、DL) 储存特性： AH：高位字节 AL：低位字节 AH(byte)+AL(byte)=字(word) 几条汇编指令 PS：当寄存器中计算进位溢出时，最高位丢失(非真正丢失) 操作对象： 物理地址8086CPU是16位CPU，有下列特性： 运算器一次最多可以处理16位的数据 寄存器的最大宽度为16位 寄存器和运算器之间的通路为16位 即能够 一次性处理、运输、暂时存储 的信息最长是16位的。 8086CPU给出物理地址的方法8086地址总线宽度为20，达1MB寻址能力，一次却只能送出16位地址(64KB寻址能力) 所以8086采用两个16位地址合成的方法形成一个20位的物理地址 算法：物理地址=段地址X16+偏移地址 段单个寄存器或多个寄存器合为一组都可以作为一段 16位地址的寻址能力为64KB，所以一个段的长度最大为64KB 段寄存器CS、DS、SS、ES CS(代码段寄存器)和IP(指令指针寄存器)是8086CPU中最关键的两个寄存器 即任意时刻，8086CPU将CS:IP指向的内容当做指令进行 指令实现过程： 开机启动指令： 最后三张图特别注意： 修改CS、IP的指令程序员通过改变CS、IP中的内容来控制CPU执行目标指令 “mov”指令可修改大部分中的内容，被称为传送指令，却不能修改CS、IP中的内容(8086没有提供这样的功能) 能够改变CS、IP内容的指令被称为转移指令 ​ “jmp”为一转移指令 ​ 也可以 代码段存放指令代码的内存被称为代码段 将CS：IP指向代码段中第一条指令的首地址，以执行代码 如：一段代码存在123B0H~123B9H中，令CS=123BH、IP=0000H 寄存器(内存访问)","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://example.com/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"关于本博客","slug":"关于本博客","date":"2021-04-19T10:31:41.000Z","updated":"2021-04-19T11:25:31.389Z","comments":true,"path":"2021/04/19/关于本博客/","link":"","permalink":"http://example.com/2021/04/19/%E5%85%B3%E4%BA%8E%E6%9C%AC%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"关于本博客怀着建立一个自己博客的热情与憧憬，我开始倒腾了… 本博客的初衷 技术分享 学习心得 杂谈 记事 吐槽 经验分享 … 版本记录V0.1.0 基于hexo theme:3-hexo 2021.4.18 本博诞生 :D 搭建心得基于hexo操作环境及工具 Node.js hexo git npm Windows10专业版 注意事项 powershell全程以管理员权限运行 git请先初始化设置邮箱及用户名 若部署失败，没有头绪，推倒重来即可，不必纠缠 hexo文档：https://hexo.io/zh-cn/docs 在对网站进行操作前，合理使用hexo clean，避免不必要错误 安装hexo若npm下载太慢，可以选装cnpm &#40;npm的中国镜像，淘宝团队负责&#41; 命令与npm完全相同，仅npm-&#62;cnpm npm install -g cnpm --registry=https://registry.npm.taobao.org 淘宝团队：&#34;这是一个完整 npmjs.org 镜像，你可以用此代替官方版本&#40;只读&#41;，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。&#34;官方网址：http://npm.taobao.org 使用以下命令全局安装hexo npm install -g hexo-cli 剩下的环境及工具的安装过程请自行搜索，在此不进行赘述 前置环境及工具配置完成后，在你的理想目录下建立空blog文件夹(可为任意合法名字&#41;，powershell进入空blog文件夹进行操作&#40;下文简称blog目录&#41; 使用 hexo init 对博客进行初始化，完成后目录如下 使用以下命令 hexo s 在浏览器访问 localhost:4000 进行预览，预览完成在powershell使用ctrl+c结束预览&#40;在写完博客后常需预览效果&#41; 部署在Github Pages在github中新建仓库，仓库名前缀必须和你的用户名一致，格式:用户名.github.io 由于我已经建立了仓库，所以报错，大家直接按照格式填就好 接着在blog目录下找到 “_config.yml”文件 &#40;重要文件,要用好&#41;，用文本编辑器打开，找到deploy并按以下格式填写&#40;注意yml格式，冒号后要有一个空格&#41; type 是管理方式 repo 是仓库地址 branch 默认为master 实际上不止有git一种管理方式，感兴趣可以自寻它法… Github Pages有三个要求&#40;或者你可以参考Github Pages官方指南&#41; 有README.md 选对分支 Choose a theme 在仓库的setting栏下找到Pages项 Source项按如图所示设置好并Save 接着Choose a theme 找一个喜欢的就行，选择Select theme 于是在powershell hexo g 生成静态文件 hexo d 部署网站 就会看见自己的github仓库多了网站文件 若看到的是还是空，那么可能分支选错了 如下图，此处应选master&#40;可去setting更改default branche&#41; 更改主题可以在github上搜索hexo寻找主题，git clone到blog目录下themes文件夹中 并在_config.yml文件中更改theme一栏内容为要使用的主题的文件夹名 这里使用yilia 先使用 hexo clean 清除缓存，再使用 hexo g 生成静态网页 ，最后用 hexo d上传至Pages 常见问题部署若出现404，则可能是Pages的三个要求没有满足&#40;参考上文或Github官方Pages文档&#41;或者仓库名格式不对&#40;账户名.github.io&#41; 若部署成功，但css和js内容无法显示，大概率是由于_config.yml文件设置失误或者你的文件路径设置有问题 主题设置安装例如”next”等主题时&#40;在Github上很火，但我更喜欢3-hexo&#41;，刷新页面显示 &#123;% extends ‘_layout.swig‘ %&#125; &#123;% import ‘_macro/post.swig‘ as post_template %&#125;... 的问题，原因是hexo在5.0之后将swig删除了，需要自己手动安装 使用powershell进行安装： npm i hexo-renderer-swig","categories":[{"name":"博客","slug":"博客","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-04-18T12:21:13.353Z","updated":"2021-04-18T12:21:13.353Z","comments":true,"path":"2021/04/18/hello-world/","link":"","permalink":"http://example.com/2021/04/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"博客","slug":"博客","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"经济学","slug":"经济学","permalink":"http://example.com/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"},{"name":"开发文档","slug":"开发文档","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/"},{"name":"汇编","slug":"汇编","permalink":"http://example.com/tags/%E6%B1%87%E7%BC%96/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"}]}